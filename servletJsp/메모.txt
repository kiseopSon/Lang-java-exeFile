<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>

<!-- context.xml : db통신의 기본적인 구성을 미리 적어넣음. 탬플릿과 연관시켜놓으면 또 작성할 일이 없다. maxActive : 최대이용자수 -->
<!-- service/DBservice.java : context를 활용해 db연결을 시도하는곳. 연결오류는 여기서 잡는다. -->
<!-- jdbc_templ.xml : 기본탬플릿. _치고 만들어놓은 메서드를 치면 이클립스내에서 검색이 가능하다. 해당파일은  mvc패턴용으로 만들어져 있다. -->
<!-- 아파치의 commons- 콜렉션,dbcp,pool,ojdbc6(20.04월 현재버전) : context와 같이 db때 필요한 필수 .jar파일이다.-->
<!-- dao : 실질적으로 연결된 db에 명령을 자바언어로 주는곳. 정확한 포지션은 여기서 정해진다. 예)insert,delete, update,select -->
<!-- 서버는 한번에 여러개를 열면 문제가 생기니 각 프로젝트가 끝낫으면 연결을 끊어주거나  어느정도 차면? 다시 서버를 파야한다. -->
<!-- JNDI : 데이터베이스 접속할때 편리하게 해주는 API = DAO/SELECT내용전부 같은 LOOKUP사용하는 그런거 -->
<!-- jsp거치기전 서블릿이 있다면, db접속하기전 myBatis가 있다. -->
-------------------------------------------------------여기까지 db------------------------------------
<!-- 프로젝트 오른쪽 버튼 -> 빌드패스 -> 콘피규어 빌드패스에서 다 체크 : 자바버전이 안맞으면 다른데서 가져온 프로그램을 인식오류를 낸다. 특히 jsp는 그렇다. -->
<% %> <!-- 스크립트릿 : 일반적으로 jsp 인라인 자바언어를 작성하는데 사용되는 구간. 특별히 영역을 잡는다. @ : 선언, = : 결과출력 도 붙인다.  -->
<!-- 스크립트릿 말고 다른 방식인 el표기법을 사용하면 set어트리뷰트같은 맵(키)형식으로 저장해둔 request내용들을 바로 가져올 수 있다. -->
<!-- java.sun.com/jsp/jstl/core 등등을 입력하면  frefix="?" ?로 정한 기준을 통해 forEach문같은 내용을 jsp에서 자바스크립트말고 자바도 쓸 수 있다. 
	 C:\JSP_0331\apache-tomcat-8.5.50\webapps\examples\WEB-INF\lib 해당경로를 잘확인해서 taglib의impl과 spec라고 써있는 파일을 맨앞 톰캣 라이브러리에 넣으면,
	 스크립트릿을 안쓰고, forEach문같은 문장을 사용할 수있다.-->
<!-- jsp는 한번 오류표시하면 멍청해서 오류수정이 안되니 개무시하면된다. 단, el표기법같은 자바코드는 정확히 잡으니 그점은 유의해야 한다. -->
<!-- mvc패턴은 싱글톤패턴이라 하고, 객체를 한번 선언하여  객체를 1번만 사용하여, 정확한 역할과 각자의 장점을 활용해 속도와 보완성을 높이고자 하는 요즘 제작 방식이다.
	m : model = 서블릿 - 내부처리/서버처리,
	v : view = jsp/html - 사용자display,
	c : control = dao/vo - 데이터를 실제적으로 담고 보내주는 곳. = 중앙관제탑역할 : dao -->
<!-- 기본적으로 getparameter로 set어튜리뷰트된 request의 영역이나 session영역의 내용을 키값으로 가져온다. -->
<!-- request는 지역개념을갖고, session은 전역개념을 갖는다. 그래서 object == application-->
<!-- HttpServletResponse response : 이건 return이라고 봐야 이해하기 쉽다. 다른말론 콜백메서드라고 부른다. -->
<!-- RequestDispatcher disp = request.getRequestDispatcher("보여줄 해당주소.jsp");
	 disp.forward(request, response); 두개는 세트이다. 
	 request영역에 set어트리뷰트로 저장하고, 실질적으로 데이터를 보여주기위해 보낼때 사용. -->
<!-- forword의 정확한 포지션은 컨트롤러dao가 뷰jsp를 선택할때 사용한다.
	 forword도 2가지 방식이 있는데 한가지는 일반적인dispacher를 쓰면 url이 변경이 안되고, redirect는 url이 변경된다. 단, 서로 다른것으로 인식한다. -->
<!-- Webcontent영역은 개발자를 위한공간, 사용자가 볼수 있는공간은 절대경로라고 해서 따로 잡고있다. 
	  만약, 포맷할일이 있다면 절대경로에 있는 내용은 꼭 백업해놔야 문제가 생기지 않는다. -->
<!-- jsp는 this.form타입으로 보내주는걸 일반적으로 사용하고, 내용을 한꺼번에 보낸다. document상에서 한번에 확인할 수 있고, 한번에 보내는데 용이하다. -->
<!-- location.href="" 를 통해 강제적으로 해당 페이지로 이동시킬 수 있다. -->
<!-- 프로그램의 구성은 기본적으로 구역별로 나뉘어진다.
	 1. 개발자가 만들어놓은 기본 베이스를 기준으로 사용자들끼리의 데이터는 절대경로에 데이터가 오가고,Webcontent를 통해 사용자들에게 공지사항을 올린다. 
	 2. jsp는 4가지 구역이 있는데 보여지는 순서는 page > request > session > application순으로 page가 가장먼저 보여진다.
	 3. 개발자는 request나 session영역에 명령을 주어 page를 관리 및 통신을 한다.
	 4. 예) 사용자가 회원가입을 했고, 만들어논 기본 베이스가 인터넷 쇼핑몰이라고 가정했을때 순서.
	 		1. 접속중 -> db확인 -> 맞으면 로그인/실패 -> 웹사이트 display -> 상품 검색 -> location.href="?"로 이동.
	 		2. 상품 구매요청 -> 수량 체크 및 컬러선택 -> request를 통해 서블릿에 접속 -> vo거치고 dao에서 db에 명령 -> 다시 서블릿을 거치고, 다음페이지 이동. 
	 		3. 구매방식(카드/현금결제)결정 후, 확인버튼 -> 위와같은 방식 반복 -> 설정해논 남은 수량 db -1처리 및 동시에 절대경로에 있던 내용 수정요청.
	 		4. 사용자는 여기끝, (개발자)서블릿을 통해 수정요청받은 ajax서버통신 -> 개발자의 환경에 직접접속 ->데이터 삭제 -> 완료.
	 		정리 : vo -> dao -> 서블릿 -> db/(+ajax)jsp -> display. -->
<!-- display된 내용은 대부분 request영역에 잡히고, 거기서 모든게 오간다고 생각하면 이해가 빠르다. -->
<!-- 세션은 서버의 메모리 램을 사용하기 떄문에 많이 쓸 수록 브라우저를 느리게 만들고, 비용이 상승한다. -->
<!-- 쿠키는 기본 30분이나 브라우저를 닫으면 사라지지만, 강제적으로 시간을  늘릴 수 있다. 다른말로 세션쿠키라고도 불린다. 서버에서 사용자의 컴퓨터에 설치하는 작은 기록정보 파일. -->
<!-- 쿠키는 웹브라우저의 f12의 누르고 application의 cookies에 있다. 브라우저를 방문할때 마다 새롭게 쿠키를 받아온다 .-->
<!-- 콜백 메서드 ~= 플래그 : a-> b-> c-> a 를 미리 정한 눈속임. -->
<!-- 절대경로는 ServletContext의 getrealpath로 정한다. -->
<!--   ServletContext : application 이라고불리고, (다이렉트(=당사자))request.get~~를 만든다. : 현재 프로젝트의 전체 객체를 담고 있다. 가장 상위객체. == object개념  -->
<!-- 데이터의 전송 실패여부는 vo를 통해서 내부처리한다. -->
-----------------------------------------여기까지 기본 개념------------------------------------------------
<!--  cos.jar : 멀티파트리퀘스트같은 파일을 포함한 일반 파라미터를 받아와야할때 사용되는 특수 메서드. 파일을 업로드할때 이름이 같지않게
	  			new DefaultFileRenamePolicy() 같은 메서드를 섞어서 사용된다. -->
<!-- request.setCharacterEncoding("utf-8"); 이건 포스트떄 한글이 깨지는걸 방지한다. -->
----------------------------------------------여기까지 그밖의 필요파일 제공----------------------------------
<!-- js/httpRequest : ajax통신을 위해 필수로 가지고 있어야하고, JavaScript를 이용하여 서버정보를 보낼때 클래스 인스턴스를 제공한다. == context.xml
					   정리 : 인터넷종류에 따라 실행엔진이 있는데 거기에 정보를 주고 받는다.  -->
<!-- ajax는 국제 규격이 있어서 꼭 json타입이라고 하는 방식으로 보내야 하는데 다음과 같다. String.format("[{'param':'%s'}]", param); -->
<!-- ajax통신의 결과를 받아올때 사용하는 방식 : 서블릿에서만 사용되는방식. 위에 내용을 보내준다.
								 	  response.getWriter().println(result); == 예) return (int)result; -->
<!-- 서블릿은 한번만들면 객체명을 dao와 똑같이 만들어야한다. 모바일공부할떄 특히 문제를 삼는다. -->
<!-- sendRequest(url,param, resultFn,"POST") : 다음을 통해 경로와 보내야할 값을 보낸다. 예) insert.do?idx=1
											     여기서 결과를 resultFn을 받고, 제대로 전송되었는지는 내부처리한것을 확인받는 용도로 사용된다. 전송 방식도 정한다. -->
<!-- json으로 보낸 타입은 그냥 String 타입 내용이지 실제 바뀌진 않았으니 바꾸려면 리턴받은? 서블릿정보는 xhr.responseText에 담기고,
     eval()메서드를 통해 받아야 정상적으로바뀐다. -->
<!-- xhr.readyState == 4 && xhr.status == 200 : 이건 그냥 외우자. 서버통신 성공했을때 사용하는 방식과 오류 넘버. 대소문자 구분 필수! -->
-----------------------------------------------여기까지 ajax통신-----------------------------------------